<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于IDEA搭建Spring Boot项目]]></title>
    <url>%2F2019%2F06%2F04%2F%E5%9F%BA%E4%BA%8EIDEA%E6%90%AD%E5%BB%BASpring-Boot%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[每一次的努力，只为了证明更好的自己 Spring Boot 致力于简洁，让开发者写更少的配置文件，由于Springboot内置了Servlet容器，所以程序不需要像传统的方式，先部署到容器然后再启动容器。只需要打开创建包目录文件下${项目名}Application.java文件运行main方法即可。 搭建Spring boot项目springboot项目可以在https://start.spring.io/上创建项目进行下载，并在本地运行，也可在IDEA中进行构建。本次演示采用IDEA的方式。 打开IDEA点击Create New Project 选择Spring Initializr 点击NEXT Name：springbootdemo 点击NEXT 点击Web选中WEB复选框然后NEXT Project name：springbootdemo 点击FINISH 至此一个SpringBoot项目就创建完成了 结构目录 如上图所示，Spring Boot的基础结构一共是三个文件： src/main/java 程序开发以及主程序入口 src/main/resources 项目相关配置文件 src/test/java 测试程序文件 pom.xml文件可以看到工程中有maven的pom文件，这里默认是依赖了springboot的2.1.4版本，由于是测试，就不怂有什么问题，可以起到测试效果即可，构建项目不建议使用最新的；可以看到其中的一些依赖jar包比较少，因为这些都是内嵌到了springboot的jar依赖 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springbootdemo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; Application其中有一个Application类，它就是程序的入口，右键选择Run即可启动该项目（ps：默认端口号为8080） 12345678@SpringBootApplicationpublic class SpringbootDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootDemoApplication.class, args); &#125;&#125; 在resources下面有一个application.properties配置文件，负责配置项目中的一下配置信息，默认为空；一般是采用.yml的形式进行配置，可以右键选择此配置文件将其后缀进行修改 编写一个controller12345678910111213141516/** * 等同于@Controller加上@ResponseBody */@RestControllerpublic class HelloController &#123; /** * 访问/hello或者/hi任何一个地址，都会返回同样的结果 * @GetMapping等用于@RequestMapping(method = RequestMethod.GET) * @return */ @GetMapping(value = &#123;"/hello","/hi"&#125;) public String say() &#123; return "How are you?"; &#125;&#125; 运行SpringbootDemoApplication的main方法就会启动项目，打开浏览器输入网址：localhost:8080/hi，就可以在浏览器上看到：How are you? 属性配置在appliction.yml文件中添加属性： 1234girl: name: 小花 age: 18 content: content:$&#123;name&#125;,age:$&#123;age&#125; 在Java文件中，获取name属性，如下： 12345678@Value("$&#123;name&#125;")private String name;@Value("$&#123;age&#125;")private Integer age;@Value("$&#123;content&#125;")private String content; 也可以通过ConfigurationProperties注解，将属性可以配置到Bean，通过Component注解将bean注解到spring`容器中： 1234567891011121314151617181920212223@ConfigurationProperties(prefix="girl")@Componentpublic class GirlProperties &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 总结使用SpeingBoot可以非常方便、快速搭建项目，spring项目就相当于是个光脚大汉，boot…boot给你双鞋总跑得过光脚的吧。另外SpringBoot也是构建Springcloud微服务架构的基础 参考https://www.cnblogs.com/ityouknow/p/5662753.htmlhttps://blog.csdn.net/forezp/article/details/61472783]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java枚举Enum类型用法]]></title>
    <url>%2F2019%2F06%2F04%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%9E%9A%E4%B8%BEEnum%E7%B1%BB%E5%9E%8B%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[你只看到了她表面的坚强，却不知她内心的脆弱 枚举（enum），是指一个经过排序的、被打包成一个单一实体的项列表。一个枚举的实例可以使用枚举项列表中任意单一项的值。枚举在各个语言当中都有着广泛的应用，通常用来表示诸如颜色、方式、类别、状态等等数目有限、形式离散、表达又极为明确的量。Java从JDK5开始，引入了对枚举的支持 在枚举出现之前，如果想要表示一组特定的离散值，往往使用一些常量。例如： 12345678910111213141516171819202122232425package com.fhp.enumexample; public class Entity &#123; public static final int VIDEO = 1;//视频 public static final int AUDIO = 2;//音频 public static final int TEXT = 3;//文字 public static final int IMAGE = 4;//图片 private int id; private int type; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getType() &#123; return type; &#125; public void setType(int type) &#123; this.type = type; &#125; &#125; 当然，常量也不仅仅局限于int型，诸如char和String等也是不在少数。然而，无论使用什么样的类型，这样做都有很多的坏处。这些常量通常都是连续、有无穷多个值的量，而类似这种表示类别的量则是离散的，并且通常情况下只有有限个值。用连续的量去表示离散量，会产生很多问题。例如，针对上述的Entity类，如果要对Entity对象的type属性进行赋值，一般会采用如下方法： 123Entity e = new Entity();e.setId(10);e.setType(2); 这样做的缺点有：（1）代码可读性差、易用性低。由于setType()方法的参数是int型的，在阅读代码的时候往往会让读者感到一头雾水，根本不明白这个2到底是什么意思，代表的是什么类型。当然，要保证可读性，还有这样一个办法： 1e.setType(Entity.AUDIO); 而这样的话，问题又来了。这样做，客户端必须对这些常量去建立理解，才能了解如何去使用这个东西。说白了，在调用的时候，如果用户不到Entity类中去看看，还真不知道这个参数应该怎么传、怎么调。像是setType(2)这种用法也是在所难免，因为它完全合法，不是每个人都能够建立起用常量名代替数值，从而增加程序可读性、降低耦合性的意识 （2）类型不安全。在用户去调用的时候，必须保证类型完全一致，同时取值范围也要正确。像是setType(-1)这样的调用是合法的，但它并不合理，今后会为程序带来种种问题。也许你会说，加一个有效性验证嘛，但是，这样做的话，又会引出下面的第(3)个问题 （3）耦合性高，扩展性差。假如，因为某些原因，需要修改Entity类中常量的值，那么，所有用到这些常量的代码也就都需要修改——当然，要仔细地修改，万一漏了一个，那可不是开玩笑的。同时，这样做也不利于扩展。例如，假如针对类别做了一个有效性验证，如果类别增加了或者有所变动，则有效性验证也需要做对应的修改，不利于后期维护 （4）常量作为参数时，是String，int等弱类型，开发人员可以传入没有在常量接口里定义的值，这个问题无法通过编译器发现 （5）编译时，是直接把常量的值编译到类的二进制代码里，常量的值在升级中变化后，需要重新编译引用常量的类，因为里面存的是旧值 （6）如果常量类的构造器不私有，无法限制开发员继承/实现接口，开发员能够在子接口里继续添加常量.而这些常量可能得不到祖先层的支持 枚举就是为了这样的问题而诞生的。它们给出了将一个任意项同另一个项相比较的能力，并且可以在一个已定义项列表中进行迭代。枚举（在Jave中简称为enum）是一个特定类型的类。所有枚举都是Java中的新类java.lang.Enum的隐式子类。此类不能手工进行子类定义。一个简单的枚举可以是这样： 12345package com.fhp.enumexample; public enum TypeEnum &#123; VIDEO, AUDIO, TEXT, IMAGE&#125; 上面的Entity类就可以改成这样： 123456789101112131415161718192021package com.fhp.enumexample; public class Entity &#123; private int id; private TypeEnum type; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public TypeEnum getType() &#123; return type; &#125; public void setType(TypeEnum type) &#123; this.type = type; &#125;&#125; 在为Entity对象赋值的时候，就可以这样： 123Entity e = new Entity();e.setId(10);e.setType(TypeEnum.AUDIO); 怎么看，都是好了很多。在调用setType()时，可选值只有四个，否则会出现编译错误，因此可以看出，枚举是类型安全的，不会出现取值范围错误的问题。同时，客户端不需要建立对枚举中常量值的了解，使用起来很方便，并且可以容易地对枚举进行修改，而无需修改客户端。如果常量从枚举中被删除了，那么客户端将会失败并且将会收到一个错误消息。枚举中的常量名称可以被打印，因此除了仅仅得到列表中项的序号外还可以获取更多信息。这也意味着常量可用作集合的名称，例如HashMap 基本enum特征所有创建的枚举类都继承自抽象类 java.lang.Enum; 一个枚举类，所有实例都要在第一句写出以 ，隔开。 如果只有实例最后可以不加 ； 枚举类因为继承了Enum,所以再不能继承别的类，任何类也不能继承枚举类（构造器默认为private） 123456public enum Color &#123; RED, BLUE, YELLOW, PURPLE&#125; 注意 ：RED,BLUE 这些是由 enum Color类调用默认private构造器创建的实例对象，和普通class相比只不过enum的实例对象只能在内部创建。时刻记着他们是一个实例对象 枚举类实例不能在外部 new 出来 ，因为枚举类构造器为private 一般也不用声明private，默认就是private，因为enum实例只能在编译期间enum类内部被创建，但可以外部得到一个实例的引用 12Color red = Color.RED;Color blue = Color.BLUE; 枚举类的一些方法 使用枚举元素 Color.RED 或者 red Color.values( ) 返回一个枚举类数组，数组元素就是枚举的实例。 red.ordinal() 方法返回该实例声明的次序从0开始。 2个实例可用 == 比较 Enum 实现了 Comparable和 Serializable 可以使用comparableTo( )方法，可以序列化 a. getDeclaringClass() 返回 Color.class 对象 a.name和a.toString( )方法一样。 ​ valuesOf(string ) 返回一个实例对象 Color b = Color.valueOf(“BLUE”); 根据class对象返回实例 Color b = Color.valueOf( Color.class, “BLUE” ) 通过带参构造器为枚举实例添加描述信息。调用 getDes()就可以的到当前对象的描述信息 调用 getDes( )方法就可以的到当前对象的描述信息 12345678910111213public enum Color &#123; RED("这是红色"), BLUE("这是蓝色"), YELLOW("这是黄色"), PURPLE("这是紫色"); String des; Color( String s) &#123; this.des = s; &#125; public String getDes()&#123; return des; &#125;&#125; 重写toString( )方法来为enum实例添加描述信息 123456789101112public enum Color &#123; RED, BLUE, YELLOW, PURPLE; @Override public String toString() &#123; String id = name(); return id + " is " + id.toLowerCase(); &#125;&#125; 通过name() 拿到当前对象名字 enum的特殊方法除了不能继承enum类外，enum和其普通类没区别，可以添加字段，方法，甚至是main 方法 enum 实例也可以用在 switch语句中 values()方法不在Enum中 它是由编译器添加的static方法 编译器还添加了一个valuesOf(String s)方法，这个只需要一个参数就可以的得到实例，而Enum的需要2个 如果将enum向上转型为Enum那么values 和 valuesOf 无法再使用 与values 方法有相同作用的就是Class对象的getEnumConstants()，如果class是枚举类那么返回元素数组，不是枚举类返回null 使用接口组织枚举为了实现扩展enum 或者将enum分类，因为无法继承所以靠扩展子类无法实现，可以利用接口来达到这些功能 123456789101112131415161718public interface Food &#123; enum Fruit implements Food&#123; APPLE, BANANA, ORANGE; &#125; enum Vegetables implements Food&#123; TOMATO, POTATO, BEANS; &#125; enum Drink implements Food&#123; COFFEE, COCA, REDBULL; &#125;&#125; public static void main(String[] args) &#123; Food food = Food.Fruit.APPLE; food = Food.Drink.REDBULL; food = Food.Vegetables.BEANS; &#125; 接口基础上创建一个枚举的枚举，通过该enum控制其他enum，而不是不同的类型分别都要向上转型为Food ，类多时分别向上转型不如每个用一个enum控制方便 通过实例调用getValues方法就可以的到该实例的所有元素 123456789101112public enum Course &#123; FRUIT(Food.Fruit.class), DRINK(Food.Drink.class), VEGETABLES(Food.Vegetables.class); private Food[] values; Course(Class&lt;? extends Food&gt; kind) &#123; this.values = kind.getEnumConstants(); &#125; public Food[] getValues() &#123; return values; &#125;&#125; enum嵌套在另一个enum 重新组织1 2 代码合二为一 1234567891011121314151617181920212223242526272829public enum Course &#123; FRUIT(Food.Fruit.class), DRINK(Food.Drink.class), VEGETABLES(Food.Vegetables.class); private Food[] values; Course(Class&lt;? extends Food &gt; kind) &#123; this.values = kind.getEnumConstants(); &#125; interface Food &#123; enum Fruit implements Food &#123; APPLE, BANANA, ORANGE; &#125; enum Vegetables implements Food &#123; TOMATO, POTATO, BEANS; &#125; enum Drink implements Food &#123; COFFEE, COCA, REDBULL; &#125; &#125; public Food[] getValues() &#123; return values; &#125; &#125; EnumSetEnumSet （抽象类）一个用来存放enum 元素的Set,存取enum速度非常快，性能非常高 EnumSet 只能存放enum元素，不能插入空元素 放入的元素位置和enum中保持一样，它处于排序状态，是一个有序Set Enum 是个抽象类且方法除了colon( )克隆一个EnumSet外都是静态方法返回值都是EnumSet 123EnumSet&lt;Color&gt; enumSet = EnumSet.noneOf(Color.class); //创建一个空集EnumSet&lt;Color&gt; enumSet2 = EnumSet.allOf(Color.class); //把集合中所有元素添加进去EnumSet&lt;Color&gt; enumSet3 = EnumSet.of(RED);//添加一个元素 EnumSet不止这几个方法，对于of() 方法重载了6次，当传入2-5个参数调用相应方法，传入1个或者5个以上调用可变参数 EnumMap特殊Map（类），key必须是enum, 由于enum元素有限所以内部只是由数组实现 这是一个有序map，保持enum的元素顺序 EnumMap&lt;Color,Object&gt; map = new EnumMap&lt;Color, Object&gt;(Color.class) 方法和其他Map一样 实例对象添加方法为每一个enum实例（相当于常量）添加一个方法，让他们有不同的行为 为每一个实例添加不同行为的方法 在enum中创建一个或者多个abstract 方法，因为是enum的实例所以就得实现这些方法 12345678910111213RED&#123; @Override String getInfo() &#123; return null; &#125; @Override String getTime() &#123; return null; &#125; &#125;; abstract String getInfo(); abstract String getTime(); enum也可以有main方法作为enum执行入口 常量添加方法后和有了类的行为，貌似和内部类一样，但他们有着不同行为，enum的常量不能作为方法参数类型，因为他们不是类，只是enum类型的static final 实例 由于enum的常量是 static final 的所以常量的方法不能访问外部类的非静态方法 覆盖常量相关的方法 enum中所有非抽象方法每个实例都可以调 如果不需要每个实例都实现抽象类，那么就可以不用定义抽象类，每个实例各自实现方法，实现的方法可以覆盖enum中的方法 使用enum职责链 多种不同的方式解决问题，然后把它们连接在一起，但一个请求到达时遍历整个链，直到解决问题 enum非常适合作为解决某一个问题的职责链，请求到达时遍历整个enum，直到解决问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.EnumSet;import java.util.Random;public enum COR &#123; SOLUTION_ONE&#123; @Override boolean Solve(int i) &#123; if (i == 1)&#123; System.out.println(name()+" 解决问题 " +i); return true; &#125; return false; &#125; &#125;, SOLUTION_TWO&#123; @Override boolean Solve(int i) &#123; if (i == 2)&#123; System.out.println(name()+" 解决问题 " +i); return true; &#125;return false; &#125; &#125;, SOLUTION_THREE&#123; @Override boolean Solve(int i) &#123; if (i == 3)&#123; System.out.println(name()+" 解决问题 " +i); return true; &#125;return false; &#125; &#125;, SOLUTION_FOUR&#123; @Override boolean Solve(int i) &#123; if (i == 4)&#123; System.out.println(name()+" 可以解决问题 " +i); return true; &#125;return false; &#125; &#125;; abstract boolean Solve(int i); public static void main(String[] args) &#123; Random random = new Random(); EnumSet&lt;COR&gt; cors = EnumSet.allOf(COR.class); for (int i = 0; i &lt; 6; i++) &#123; int id = random.nextInt(4)+1; for (COR cor :cors) &#123; if (cor.Solve(id))&#123; System.out.println(" 解决问题 " +id); break; &#125; &#125; &#125; &#125;&#125; enum状态机 状态机可以具有 有限个 状态，通常根据输入，从一个状态转移到下一个状态，也可以有瞬时状态，一但任务结束就立刻离开瞬时状态 多路分发 多种类型交互时有时并不能确定所有类型，如： NUM.complete(NUM) , NUM 是所有数字类型的超类，a.complete(b) ,a b可能是同种类型也可能不是同一种类型 Java 动态绑定只能处理一种类型，属于单路分发（分派），动态绑定能将complete绑定到分路a。只有方法调用才会执行动态绑定 可以为每一个分发实现自己的动态绑定 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public enum Outcome &#123; WIN, LOSE, DRAW &#125; ///:~ interface Item &#123; Outcome compete(Item it); Outcome eval(Paper p); Outcome eval(Scissors s); Outcome eval(Rock r); &#125; class Paper implements Item &#123; public Outcome compete(Item it) &#123; return it.eval(this); &#125; public Outcome eval(Paper p) &#123; return DRAW; &#125; public Outcome eval(Scissors s) &#123; return WIN; &#125; public Outcome eval(Rock r) &#123; return LOSE; &#125; public String toString() &#123; return "Paper"; &#125; &#125; class Scissors implements Item &#123; public Outcome compete(Item it) &#123; return it.eval(this); &#125; public Outcome eval(Paper p) &#123; return LOSE; &#125; public Outcome eval(Scissors s) &#123; return DRAW; &#125; public Outcome eval(Rock r) &#123; return WIN; &#125; public String toString() &#123; return "Scissors"; &#125; &#125; class Rock implements Item &#123; public Outcome compete(Item it) &#123; return it.eval(this); &#125; public Outcome eval(Paper p) &#123; return WIN; &#125; public Outcome eval(Scissors s) &#123; return LOSE; &#125; public Outcome eval(Rock r) &#123; return DRAW; &#125; public String toString() &#123; return "Rock"; &#125; &#125; public class RoShamBo1 &#123; static final int SIZE = 20; private static Random rand = new Random(47); public static Item newItem() &#123; switch (rand.nextInt(3)) &#123; default: case 0: return new Scissors(); case 1: return new Paper(); case 2: return new Rock(); &#125; &#125; public static void match(Item a, Item b) &#123; System.out.println(a + " vs. " + b + ": " + a.compete(b)); &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; SIZE; i++) match(newItem(), newItem()); &#125; &#125; 使用enum实现多路分发 enum的实例不能作为类型参数，不可以重载方法 可以使用enum构造器初始化每个enum实例，并以一组结果作为参数如 ENUM_A( vsA_DRAW, vsB_LOSE, vsC_WIN ) 在比较方法中使用switch 判断 返回 结果 123456789101112131415161718192021222324252627282930313233package enums;import static enums.OutCome.*;public enum RoSham &#123; PAPER(DRAW, LOSE, WIN), SCISSORS(WIN, DRAW, LOSE), ROCK(LOSE, WIN, DRAW); private OutCome vPAPER, vSCISSORS, vROCK; RoSham(OutCome paper, OutCome scissors, OutCome rock) &#123; this.vPAPER = paper; this.vSCISSORS = scissors; this.vROCK = rock; &#125; public OutCome complete(RoSham it) &#123; switch (it) &#123; default: case PAPER: return vPAPER; case SCISSORS: return vSCISSORS; case ROCK: return vROCK; &#125; &#125; public static void main(String[] args) &#123; System.out.println(PAPER.complete(ROCK)); &#125;&#125; PAPER.complete（）时把PAPER构造器中的结果与 OutCome 变量绑定，根据对比的参数返回对比结果，因此实例构造器中的参数位置非常重要 EnumMap实现真正的多路分发 123456789101112131415161718192021222324252627282930313233343536373839package enums;import java.util.EnumMap;import static enums.OutCome.*;public enum RoShamBo &#123; PAPER, SCISSORS, ROCK; static EnumMap&lt;RoShamBo, EnumMap&lt;RoShamBo, OutCome&gt;&gt; table = new EnumMap&lt;RoShamBo, EnumMap&lt;RoShamBo, OutCome&gt;&gt;(RoShamBo.class); static &#123; for (RoShamBo it : RoShamBo.values()) &#123; table.put(it, new EnumMap&lt;RoShamBo, OutCome&gt;(RoShamBo.class)); &#125; initRow(PAPER, DRAW, LOSE, WIN); initRow(SCISSORS, WIN, DRAW, LOSE); initRow(ROCK, LOSE, WIN, DRAW); &#125; static void initRow(RoShamBo it, OutCome vPAPER, OutCome vSCISSORS, OutCome vROCK) &#123; EnumMap&lt;RoShamBo, OutCome&gt; row = RoShamBo.table.get(it); row.put(RoShamBo.PAPER, vPAPER); row.put(RoShamBo.SCISSORS, vSCISSORS); row.put(RoShamBo.ROCK, vROCK); &#125; public OutCome complete(RoShamBo it) &#123; return table.get(this).get(it); &#125; public static void main(String[] args) &#123; System.out.println(ROCK.complete(SCISSORS)); &#125;&#125; complete方法实现了2次分发 使用二维数组 简单，速度快，代码易懂，但是组数比较大时尺寸容易错 123456789private static OutCome[][] tables = &#123; &#123;DRAW, LOSE, WIN&#125;, &#123;WIN, DRAW, LOSE&#125;, &#123;LOSE, WIN, DRAW&#125;, &#125;; public OutCome completes (RoShamBo other) &#123; return tables[this.ordinal()][other.ordinal()]; &#125; 知识点可以静态导入枚举类 直接使用枚举实例 import static ……Color.* 最好使用静态导入省去写enum类 参考： ​ 《Java编程思想》 – 笔记 ​ https://www.cnblogs.com/mibloom/p/9508077.html ​ https://blog.csdn.net/u014527058/article/details/52751488]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>Enum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强力推荐！那些你不能错过的GitHub插件和工具]]></title>
    <url>%2F2019%2F06%2F04%2F%E5%BC%BA%E5%8A%9B%E6%8E%A8%E8%8D%90%EF%BC%81%E9%82%A3%E4%BA%9B%E4%BD%A0%E4%B8%8D%E8%83%BD%E9%94%99%E8%BF%87%E7%9A%84GitHub%E6%8F%92%E4%BB%B6%E5%92%8C%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[一个开桑塔纳的，一个开法拉利的，哪个跑得快？ 以代码托管平台起家的 GitHub 网站，已然成为全球程序员工作和生活中不可或缺的一份子。从优秀的企业，到优秀的程序员，都将自己最优秀的代码作品存放在这片开源净土里，供彼此学习交流。 GitHub Trending 栏目甚至已经成为 IT 从业人员的新闻日报，每日必读。在之前的一篇文章中，我也有讲到 GitHub 对于我们程序员个人的重要性：聊聊 GitHub 对于程序员的品牌价值。 既然 GitHub 这么重要，又被我们使用得这么频繁，那关于 GitHub 的一些优秀浏览器插件或者其他工具，我们就一定不可错过啦。本文就来整理一些，都是我平常使用最得心应手的东西，全都倾力推荐出来，绝对干货！ Chrome 扩展程序 备注：这个分类的部分均可以在 Chrome 应用商店 搜索得到，也可以直接点击小标题直接跳转至插件详情页。 Octotree很好奇的是，GitHub 作为代码托管平台，竟然没有提供项目目录，方便用户在线快速浏览项目结构。所以，在线分析项目源码就会变得很繁琐，必须一层一层点击，然后再一次一次地向上返回。要知道，本来 GitHub 网站在中国区的访问就已经很慢了。最无奈的做法就是，下载到本地，再使用 Sublime 等编辑器打开。 Octotree 作为 Chrome 浏览器的一款插件，刚好解决这个使用痛点。他能够像 IDE 一样提供项目目录，快捷导航，方便浏览。同时支持 GitHub 和 GitLab 两个常用的代码托管网站。更贴心的是，你可以自行选择是否显示目录。 GitHub Plus同样作为 Chrome 的插件，GitHub Plus 提供的功能也是非常实用。能够显示代码仓库的大小，以及其中每个文件的大小和下载链接。使用这款插件，我们再也不用因为需要某个单一文件而被迫下载整个项目源码，尤其是在网速不给力的时候。 GitHub Hovercard使用这款插件，当你将鼠标停留在 GitHub 网站的用户头像或者仓库链接地址上时，会自动弹出一个悬浮框，带你提前预览基本信息。有点类似 StackOverflow 网站的用户头像的鼠标悬停效果。Hovercard 插件支持的悬停位置更多，包括用户头像，仓库地址，Issue 链接，个人主页等。咱们还是用图说话比较直接： Sourcegraph for GitHub代码搜索，查看引用，自动跳转，项目目录导航，这些 IDE 上常用的功能操作，借助 Sourcegraph 插件，都能帮你直接在线使用。如图： Octo Mate这款插件提供的功能与前面提到的 GitHub Plus 有点类似，展示项目大小，任意文件点击下载等。如图： Awesome Autocomplete for GitHubGitHub 智能搜索插件。有点类似自动补全功能，实时监听输入的搜索关键字，自动列出相关内容。正如官方介绍那样，致力于打造 GitHub 上最好的搜索引擎，助你在搜索仓库和用户方面，比以往更快人一步。 Isometric Contributions3D 像素立体展示 GitHub 上的仓库提交记录。相比传统的方块图表，更有美感。当然，使用这款插件之后，你可以自由切换展示方式，而不是一刀切。 高效率管理工具 前面提到的都是 Chrome 的插件系列，基本上可以解决平时我们使用 GitHub 在线搜索或者浏览某一仓库时所遇到的痛点问题。但是还有一个很重要的痛点没有解决，那就是我们 Star 过的仓库管理问题。 任何一个 IT 领域，GitHub 网站都有成千上万个优秀开源项目可供参考学习。所以，收藏关注几十几百个项目是再平常不过的一件事了。没有标签，没有便捷的检索功能，如何高效率地管理这些关注过的项目呢？也许你可以尝试这些网站提供的工具。 OhMyStar2强力推荐 OhMyStar2 客户端，号称是管理 GitHub Stars 最好的方式。自动同步 GitHub 账号的 Stars，拥有标签和评分两种分类方式助你分组管理项目，根据名称、日期等指标自动排序，三方分享功能，甚至提供每日 Trending 浏览，说是最好，名符其实！ Astral也是提供标签式的方式管理 GitHub 账号关注的项目。只不过，通过网站在线管理，没有提供 PC 版客户端。免费试用。 Insight.io这个工具使用起来有点类似 IDE，提供开发中常用的快速导航、代码搜索功能、查看引用和点击跳转等功能。 我想，有了这些工具，一定能大幅提高我们程序员使用 GitHub 时的效率。工欲善其事，必先利其器。站在巨人的肩膀上，更容易事半功倍。利用好工具，换种角度来看，也是一种不可忽视的能力。 从事 IT 行业以来，越发觉得，互联网对于我们每个人来说，都是公平的，如何开拓视野，利用网络平台提升自己的学习能力和工作效率，显得尤为重要。很庆幸，我们都在这个最潮流的行业，共同学习，一起进步。 原文作者：亦枫 原文链接：http://yifeng.studio/2017/09/06/recommended-extension-tools-about-github/]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
</search>
